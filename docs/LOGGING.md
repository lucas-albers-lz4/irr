# IRR Logging and Debugging Guide

## Overview

This document provides a comprehensive guide to logging and debugging in the IRR tool, including how to:
- Control log levels and formats
- Enable debug logging
- Understand execution mode detection (Standalone vs Helm Plugin)
- Differentiate between log output (stderr) and application output (stdout)
- Troubleshoot common logging issues

## Log Levels

IRR uses the standard library's `log/slog` package for logging. Four log levels are available, in order of increasing severity:

| Level | Description | `slog` Constant | Usage |
|-------|-------------|-----------------|-------|
| DEBUG | Detailed information for troubleshooting | `slog.LevelDebug` | Internal operations, call flows, value traces |
| INFO  | General operational messages | `slog.LevelInfo` | Command execution, successful operations |
| WARN  | Potential issues that don't prevent operation | `slog.LevelWarn` | Non-critical problems, fallbacks |
| ERROR | Serious issues that prevent operation | `slog.LevelError` | Fatal errors, missing requirements |

Logs are written to **standard error (stderr)**.

## Controlling Log Level (`LOG_LEVEL`)

The minimum log level displayed is controlled by the `LOG_LEVEL` environment variable. Set it to one of `DEBUG`, `INFO`, `WARN`, or `ERROR` (case-insensitive). The default level is `INFO`.

The effective log level is determined by the following precedence (highest to lowest):

1.  **`--debug` flag:** If present, forces the log level to `DEBUG`, overriding all other settings.
2.  **`--log-level <level>` flag:** If present and `<level>` is not the default `"info"`, sets the log level to `<level>`. Overrides `LOG_LEVEL` environment variable and the default level.
3.  **`LOG_LEVEL=<LEVEL>` environment variable:** If set to a valid level, sets the log level to `<LEVEL>`. Overrides the default level.
4.  **Default Level:**
    *   **Error (`ERROR`):** Used during normal execution (standalone or Helm plugin mode). This provides a cleaner output for users, showing only warnings and errors by default.
    *   **Info (`INFO`):** Used when IRR detects it's running in a test mode (e.g., via hidden flags like `--integration-test` or `--test-analyze`). This ensures tests that rely on INFO-level logs continue to function.

**Example Scenarios:**

```bash
# Normal run: Shows only WARN and ERROR logs (default behavior)
irr <command>
# Or explicitly (same as default):
LOG_LEVEL=ERROR irr <command>

# See INFO, WARN, ERROR logs
irr <command> --log-level info
# Or:
LOG_LEVEL=INFO irr <command>

# See DEBUG, INFO, WARN, ERROR logs
irr <command> --debug
# Or:
irr <command> --log-level debug
# Or:
LOG_LEVEL=DEBUG irr <command>

# See only WARN and ERROR logs (overrides default)
LOG_LEVEL=WARN irr <command>
```

## Log Format (`LOG_FORMAT`)

IRR supports two log output formats, controlled by the `LOG_FORMAT` environment variable:

*   `json` (Default): Structured JSON format (using `slog.JSONHandler`). This is ideal for machine parsing and log aggregation systems.
    ```json
    {"time":"2023-10-27T10:00:00.123Z","level":"INFO","msg":"Processing chart","chart":"my-chart"}
    ```
*   `text`: Human-readable, key-value pairs (using `slog.TextHandler`). This format must be **explicitly requested**.
    ```
    time=2023-10-27T10:00:00.123Z level=INFO msg="Processing chart" chart="my-chart"
    ```

Set the variable like this:

```bash
# Use default JSON output format (no variable needed)
irr <command>

# Explicitly use Text output format
LOG_FORMAT=text irr <command>
```

## Enabling Debug Logging (Using `LOG_LEVEL`)

To enable debug logging, set the `LOG_LEVEL` environment variable:

```bash
LOG_LEVEL=DEBUG irr <command>
```

The legacy `IRR_DEBUG` environment variable has been removed.

## Output Streams: Logs (stderr) vs. Results (stdout)

It is crucial to understand the separation of output streams:

*   **Standard Error (`stderr`)**: Used exclusively for logs generated by the `slog` logger (`log.Debug`, `log.Info`, etc.). This includes diagnostic messages, warnings, errors, and operational status. The format is controlled by `LOG_FORMAT`.
*   **Standard Output (`stdout`)**: Used for the primary output of the command, intended for the user or for piping to other commands. This includes:
    *   Generated override files (`override` command output).
    *   Inspection results (`inspect` command output).
    *   Validation results (`validate` command output).
    *   Help messages (`help` command).

This separation ensures that diagnostic logs do not interfere with the consumable output of the tool.

## Execution Mode Detection

IRR automatically detects whether it's running as a standalone binary or as a Helm plugin.

### Detection Mechanism

The detection happens in `cmd/irr/main.go` with the `isRunningAsHelmPlugin()` function:

```go
// isRunningAsHelmPlugin checks if the program is being run as a Helm plugin
func isRunningAsHelmPlugin() bool {
    // Check for environment variables set by Helm when running a plugin
    return os.Getenv("HELM_PLUGIN_NAME") != "" || os.Getenv("HELM_PLUGIN_DIR") != ""
}
```

### Checking Execution Mode

IRR indicates its execution mode and version at startup via logs (visible if `LOG_LEVEL=DEBUG`):

```bash
# When running in standalone mode with debug enabled
LOG_LEVEL=DEBUG irr help
# Logs might include: level=DEBUG msg="Execution Mode Detected" mode=Standalone

# When running as a Helm plugin with debug enabled
LOG_LEVEL=DEBUG helm irr help
# Logs might include: level=DEBUG msg="Execution Mode Detected" mode=Plugin
```

## Troubleshooting

### Debug Flag (`--debug`) is Deprecated

The `--debug` command-line flag is deprecated and will likely be removed in future versions. Use `LOG_LEVEL=DEBUG` instead.

### Verbose Environment Information

To see environment variables used during startup (requires debug level):

```bash
LOG_LEVEL=DEBUG irr help 2>&1 | grep "msg=\"Detected environment variable\""
```

### Checking Binary Location

To verify which binary is being executed when running as a Helm plugin:

```bash
# Identify the Helm plugin path
helm plugin list | grep irr

# Check if the binary exists
ls -l ~/Library/helm/plugins/irr/bin/irr

# Confirm by removing the binary temporarily
mv ~/Library/helm/plugins/irr/bin/irr ~/Library/helm/plugins/irr/bin/irr.bak
helm irr help  # This should fail with a "no such file or directory" error
mv ~/Library/helm/plugins/irr/bin/irr.bak ~/Library/helm/plugins/irr/bin/irr
```

### Verbose Helm Plugin Environment

To see the Helm environment variables when running as a plugin:

```bash
LOG_LEVEL=DEBUG helm irr help 2>&1 | grep "HELM_"
```

## For Developers: Logging Best Practices

When adding new code to IRR, follow these guidelines for logging:

1.  Use the logging functions from the `pkg/log` package:
    *   `log.Debug(msg string, args ...any)`
    *   `log.Info(msg string, args ...any)`
    *   `log.Warn(msg string, args ...any)`
    *   `log.Error(msg string, args ...any)`
2.  Provide meaningful static messages (`msg`).
3.  Add context using structured key-value pairs (`args`). Keys should be strings. Use meaningful key names.
    ```go
    log.Info("Chart processing complete", "chartPath", chartPath, "imageCount", 42)
    log.Error("Failed to load mappings", "file", configFile, "error", err)
    ```
4.  Remember logs go to `stderr`. User-facing results should be printed to `stdout` using `fmt.Println` or similar.

## Testing Logging

### Unit Test Examples

Use the helper functions provided in `pkg/testutil`:

*   **`CaptureLogOutput(level, func) (string, error)`**: Captures text log output at the specified level.
    ```go
    output, err := testutil.CaptureLogOutput(log.LevelInfo, func() {
        log.Info("Test message", "key", "value")
    })
    require.NoError(t, err)
    assert.Contains(t, output, "level=INFO msg=\"Test message\" key=value")
    ```
*   **`CaptureJSONLogs(level, func) ([]map[string]interface{}, error)`**: Captures JSON log output, parsing each line.
    ```go
    logs, err := testutil.CaptureJSONLogs(log.LevelWarn, func() {
        log.Warn("Something might be wrong", "status", 123)
    })
    require.NoError(t, err)
    require.Len(t, logs, 1)
    assert.Equal(t, "WARN", logs[0]["level"])
    assert.Equal(t, "Something might be wrong", logs[0]["msg"])
    // Note: JSON numbers are float64 by default
    assert.Equal(t, 123.0, logs[0]["status"])
    ```
*   **`AssertLogContainsJSON(t, logs, expectedFields, ...)`**: Asserts at least one JSON log entry contains the specified fields.
    ```go
    testutil.AssertLogContainsJSON(t, logs,
        map[string]interface{}{"level": "WARN", "status": 123.0},
        "Warning log with status 123 should be present")
    ```

### Integration Test Examples

For integration tests, set environment variables to control logging:

```bash
# Run test with debug logging and JSON format
LOG_LEVEL=DEBUG LOG_FORMAT=json go test -v ./test/integration/...
```

Remember to set `LOG_FORMAT=json` in the test environment if you intend to parse the log output as JSON within the test logic. 